# ProductController
> в контроллер снова передается и репозиторий и сервис.

>А, на этом слоя я передаю только сервис, верно? Я ведь только его и использую здесь.
Контроллер работает с сервисом, сервис работает с репозиторием
```c#
private readonly IProductService _productService;

public ProductController(IProductService productService)
{
    _productService = productService;
}
```
Да все верно

## AddNewProduct
>на вход подается доменная сущьнось, как раз в даннном случае, когда что-то приходит из вне, лучше принимать DTO.
Дело в том что если вы что-то добавите в доменнную сущность, какое нибудь служебно свойство и нужно только для
внутренней логики в случае приема непосредственно доменного объекта, это отобразиться на внешних контрактах.
Да и вообще "разглашать" домменые объекты за пределы системы, плохая практика. Так-же в даном случае мы еше
и примнимаме Id продукта из вне, и это чревато проблемами, в лучшем случае мы получим ошибку о дублированнии
первичных ключчей, а в худшем, это может нарушить целостность данных БД.

Согласен. Как лучше реализовать логику перевода с ProductDTO в Product и обратно? Использовать класс `ProductMapper.cs`
или использовать существующие классы?

Обычно это делают с помощью фабричного метода, сделайте у ProductDTO 2 метода (лучше метода расширения) `Product CreateProduct()` и `ProductDTO Create(Product product)`, если знаете как то попробуйте сделайть explicit операторы тогда код у вас будет выглядеть вообше "кошерно".
```c#
ProductDTO productDTO = (ProductDTO)product;
```
и 
```c#
Product product = (Product)productDTO;
```
        
>Обработчик возвращает bool. Это не имеет смысла. Если возвращается Ok мы и так знанем что все прошло успешно,
а если  BadRequest мы знаем что пошло что-то не так. В данно случае логичнее было бы возващать Id нового продукта.

>Использовать такой подход?
 ```c#
List<Product> products = GetAllProducts();
products.Add(product);
File.WriteAllText(_filePath, JsonConvert.SerializeObject(products));
var foundedProduct = GetProductById(product.ID);
return foundedProduct.ID
 ```

Да, только не надо второй раз читать product просто верните `product.ID`

## GetAllProducts
>Получать полный список продуктов, плохая идея, это допустимо если у вас в БД будет 20-30 записей.
При большом количестве записей это будет бесполезно нагружать БД а во вторых это будет потенциальной
точкой атаки, чтобы "положить" ваш сервис. В случае получения списка данных нужно использовать пагинацию,
и всегда ограничивать выдачу на количество записей.

Принял, согласен

## GetProductById
>Аналогично, "наружу" всегда отдаем DTO.

Принял, согласен

## DeleteProductById
>Мы не можем удалить больше одной записи по Id. Здесь как раз логичнее из сервиса возвращать bool.

Принял, согласен

# UnitOfMeasurement
>Thing - это не та "штука". Это иштука из контекста complicated thing (сложная штука),
intersting thing (интересная штука). В данном случае надо использовать  piece, item или unit.
Liter - это американский вариант, по английски литр будет litre. То же самое с meter это тоже
американский вариант. По английски это будет metre.

Принял


# Product
## Id
>Идентификатор имеет публичный сеттер, это очень опасно, если в коде кто-то изменит его, это приведет
к ошибке или нарушению целостности данных.

## Amount
>делать `Ammount` `float` конечно можно, но это может "выйти боком". Наприме если у вас штучный товар,
а систему может попасть и дробное число. Я бы например сделал UnitOfUnitOfMeasurement в виде иерархии
классов, и устанавливал количество через его методы, чтобы небыло возможности из вне установить некорректное значение.

>Обдумаю. В накладных обычно количество выражается float (Молоток - 1,00 шт).

 Пусть оторбражется как угодно, и даже путь он будет float главно чтобы нельзя было указать Молоток - 1,00003356325 шт.
А такое вполне может получиться, даже не намеренно, операции с float очень коварны :)

## UnitOfMeasurement
>Убрал бы публичный сеттер, и иницализировал бы единицы измерения через конструктор, чтобы нельзя
было изменить ее в произвольном месте.

Обдумаю

## StoragePlace
>Сделал бы оттельным классом `StoragePlace` и передавал стоку в нужном формате в конструктор внутри которого
с помощью регулярного выражения проверял бы эту строку на валижность, чтобы не было возможности
создать `StoragePlace` в некорректном формате.

> ОК, и если строка не валидна что должен вернуть `_productService.AddNewProduct(newProduct)` в контроллере?
Как правильно выстроить логику по шагам?

Ну тут 2 варинанта
 1. Самый простой -  бросать исключение, и пусть фронт сам разбирается. Можно на ваш входной DTO объект навесить аттрибуты DataAnnotation и тогда фронт будет точно знать что не так.
 2. Использовать паттерн Result и возращать его из метода `_productService.AddNewProduct(newProduct)`. Это чуть сложене, надо по хорошему еще делать какой midleware, но зато вы тогда при необходимости сможете возвращать развернутую и главное человекочитаемую информацию об ошибках. И при этом и код на стороне фронта сможет распознавать удачно прогшла операция или нет.


# Abstract
>Нет смысла создавать оддельую папку. можно интерфейсы и сервисы "запихать" к корень домена или в самом
домене создайте папку Contracts и кладите туда все внешние интерфейсы и DTO

Такая иерархия получится?
```cmd
Warehouse.Domain
----Contracts
--------IProductRepository.cs
--------IProductService.cs
--------ProductDTO
----Core
--------ProductCategory.cs
--------StoragePlace.cs
--------UnitOfMeasurement.cs
----Entities
--------Product.cs
----Services
--------ProductService.cs
```
Да.

# ProductService
## IsStoragePlaceCorrect
>Это на нарушение принципа SRP (принцип единственности ответственности) провераять корректность номера места,
за предалами зоны ответствености сервиса работы с товарами. Как писал выше сделайте отдельный класс `StoragePlace` 

Принял. Хорошее замечание

## IncrementProductId
>Тоже за пределами зоны ответственности сервиса, да и конкретная реализация не безопасна, если несколько потоков
одновременно обратятся за идентификатором, то они могут получить одинаковые Id. Перренестите это метод в репозиторий
и "оберните" код в `lock`. И еще один момент, получать все элементы из репы только для того чтобы посчитать их
колиечство очень не удачное решение.

>Тут интересно..., мне очень опытный разаработчик ровно так и посоветовал сделать
(получать все элементы из репы только для того чтобы посчитать их
колиечство и инкрементить ID). Полагаю что с реальной БД можно вытягивать не все записи, а только `SELECT MAX(ID) FROM products`
Или есть более оптимальный подход?

Смотрите тут какая ситуация. Возможно вы не сможете из JSON получить сразу количество элементов без вычитывания всего списка, хотя это возможно но нужен соответсвующий скилл в регулярках.
Но это не значит что вы должны "тащить" эту особенность дальше по иерархии вызововов. Такие вещи (особенности реализации какой системы хранения) надо изолировать сразу.
Сделайте у **репозитория** метод GetProductCount, и для JSON вы можете читать все продукты в память и считать, но когда вы перейдете на SQL вам ничего больше переделывать не надо, просто напишите `SELECT COUNT(*) FROM products` и все. В вашем же случае надо будет помнить что выше по иерархии вызова есть "костыль" и при переходе на SQL надо это исправить.

И вообше все эти манипуляции с инкрементом ID надо совсем убрать из сервиса. Просто вызывайте у репы метод Add а репа уже сама вычислит и назначит ID для сущности.
