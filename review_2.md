# ProductController
> в контроллер снова передается и репозиторий и сервис.

А, на этом слоя я передаю только сервис, верно? Я ведь только его и использую здесь.
Контроллер работает с сервисом, сервис работает с репозиторием
```c#
private readonly IProductService _productService;

public ProductController(IProductService productService)
{
    _productService = productService;
}
```

## AddNewProduct
>на вход подается доменная сущьнось, как раз в даннном случае, когда что-то приходит из вне, лучше принимать DTO.
Дело в том что если вы что-то добавите в доменнную сущность, какое нибудь служебно свойство и нужно только для
внутренней логики в случае приема непосредственно доменного объекта, это отобразиться на внешних контрактах.
Да и вообще "разглашать" домменые объекты за пределы системы, плохая практика. Так-же в даном случае мы еше
и примнимаме Id продукта из вне, и это чревато проблемами, в лучшем случае мы получим ошибку о дублированнии
первичных ключчей, а в худшем, это может нарушить целостность данных БД.

Согласен. Как лучше реализовать логику перевода с ProductDTO в Product и обратно? Использовать класс `ProductMapper.cs`
или использовать существующие классы?
        
>Обработчик возвращает bool. Это не имеет смысла. Если возвращается Ok мы и так знанем что все прошло успешно,
а если  BadRequest мы знаем что пошло что-то не так. В данно случае логичнее было бы возващать Id нового продукта.

Использовать такой подход?
 ```c#
List<Product> products = GetAllProducts();
products.Add(product);
File.WriteAllText(_filePath, JsonConvert.SerializeObject(products));
var foundedProduct = GetProductById(product.ID);
return foundedProduct.ID
 ```


## GetAllProducts
>Получать полный список продуктов, плохая идея, это допустимо если у вас в БД будет 20-30 записей.
При большом количестве записей это будет бесполезно нагружать БД а во вторых это будет потенциальной
точкой атаки, чтобы "положить" ваш сервис. В случае получения списка данных нужно использовать пагинацию,
и всегда ограничивать выдачу на количество записей.

Принял, согласен

## GetProductById
>Аналогично, "наружу" всегда отдаем DTO.

Принял, согласен

## DeleteProductById
>Мы не можем удалить больше одной записи по Id. Здесь как раз логичнее из сервиса возвращать bool.

Принял, согласен

# UnitOfMeasurement
>Thing - это не та "штука". Это иштука из контекста complicated thing (сложная штука),
intersting thing (интересная штука). В данном случае надо использовать  piece, item или unit.
Liter - это американский вариант, по английски литр будет litre. То же самое с meter это тоже
американский вариант. По английски это будет metre.

Принял


# Product
## Id
>Идентификатор имеет публичный сеттер, это очень опасно, если в коде кто-то изменит его, это приведет
к ошибке или нарушению целостности данных.

## Amount
>делать `Ammount` `float` конечно можно, но это может "выйти боком". Наприме если у вас штучный товар,
а систему может попасть и дробное число. Я бы например сделал UnitOfUnitOfMeasurement в виде иерархии
классов, и устанавливал количество через его методы, чтобы небыло возможности из вне установить некорректное значение.

Обдумаю. В накладных обычно количество выражается float (Молоток - 1,00 шт)

## UnitOfMeasurement
>Убрал бы публичный сеттер, и иницализировал бы единицы измерения через конструктор, чтобы нельзя
было изменить ее в произвольном месте.

Обдумаю

## StoragePlace
>Сделал бы оттельным классом `StoragePlace` и передавал стоку в нужном формате в конструктор внутри которого
с помощью регулярного выражения проверял бы эту строку на валижность, чтобы не было возможности
создать `StoragePlace` в некорректном формате.

ОК, и если строка не валидна что должен вернуть `_productService.AddNewProduct(newProduct)` в контроллере?
Как правильно выстроить логику по шагам?

# Abstract
>Нет смысла создавать оддельую папку. можно интерфейсы и сервисы "запихать" к корень домена или в самом
домене создайте папку Contracts и кладите туда все внешние интерфейсы и DTO

Такая иерархия получится?
```cmd
Warehouse.Domain
----Contracts
--------IProductRepository.cs
--------IProductService.cs
--------ProductDTO
----Core
--------ProductCategory.cs
--------StoragePlace.cs
--------UnitOfMeasurement.cs
----Entities
--------Product.cs
----Services
--------ProductService.cs
```


# ProductService
## IsStoragePlaceCorrect
>Это на нарушение принципа SRP (принцип единственности ответственности) провераять корректность номера места,
за предалами зоны ответствености сервиса работы с товарами. Как писал выше сделайте отдельный класс `StoragePlace` 

Принял. Хорошее замечание

## IncrementProductId
>Тоже за пределами зоны ответственности сервиса, да и конкретная реализация не безопасна, если несколько потоков
одновременно обратятся за идентификатором, то они могут получить одинаковые Id. Перренестите это метод в репозиторий
и "оберните" код в `lock`. И еще один момент, получать все элементы из репы только для того чтобы посчитать их
колиечство очень не удачное решение.

Тут интересно..., мне очень опытный разаработчик ровно так и посоветовал сделать
(получать все элементы из репы только для того чтобы посчитать их
колиечство и инкрементить ID). Полагаю что с реальной БД можно вытягивать не все записи, а только `SELECT MAX(ID) FROM products`
Или есть более оптимальный подход?
